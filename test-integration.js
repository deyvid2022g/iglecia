#!/usr/bin/env node

/**
 * SCRIPT DE PRUEBA DE INTEGRACI√ìN COMPLETA
 * 
 * Este script verifica que la integraci√≥n del sistema de autenticaci√≥n personalizada
 * funcione correctamente con todas las operaciones CRUD en el proyecto principal.
 */

import { createClient } from '@supabase/supabase-js';
import bcrypt from 'bcryptjs';
import dotenv from 'dotenv';

// Cargar variables de entorno
dotenv.config();

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseAnonKey = process.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.error('‚ùå Error: Variables de entorno faltantes');
  console.error('Aseg√∫rate de tener VITE_SUPABASE_URL y VITE_SUPABASE_ANON_KEY en tu .env');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseAnonKey);

// Configuraci√≥n de prueba
const testUser = {
  email: 'test@integration.com',
  password: 'testpassword123',
  name: 'Test Integration User',
  role: 'admin'
};

let sessionToken = null;

console.log('üöÄ Iniciando prueba de integraci√≥n completa...\n');

/**
 * Funci√≥n para autenticarse y obtener token de sesi√≥n
 */
async function authenticateUser() {
  console.log('üîê Paso 1: Autenticaci√≥n de usuario...');
  
  try {
    // Buscar usuario existente
    const { data: existingUser } = await supabase
      .from('users')
      .select('*')
      .eq('email', testUser.email)
      .single();

    let userId;
    
    if (!existingUser) {
      // Crear usuario si no existe
      console.log('üë§ Creando usuario de prueba...');
      const hashedPassword = await bcrypt.hash(testUser.password, 10);
      
      const { data: newUser, error: createError } = await supabase
        .from('users')
        .insert({
          email: testUser.email,
          password_hash: hashedPassword,
          name: testUser.name,
          role: testUser.role
        })
        .select()
        .single();

      if (createError) throw createError;
      userId = newUser.id;
      console.log('‚úÖ Usuario creado exitosamente');
    } else {
      userId = existingUser.id;
      console.log('‚úÖ Usuario existente encontrado');
    }

    // Crear sesi√≥n
    console.log('üé´ Creando sesi√≥n...');
    const accessToken = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 horas

    const { error: sessionError } = await supabase
      .from('sessions')
      .insert({
        user_id: userId,
        access_token: accessToken,
        expires_at: expiresAt.toISOString()
      });

    if (sessionError) throw sessionError;

    sessionToken = accessToken;
    console.log('‚úÖ Sesi√≥n creada exitosamente');
    console.log(`üîë Token: ${accessToken.substring(0, 20)}...\n`);
    
    return { userId, accessToken };
  } catch (error) {
    console.error('‚ùå Error en autenticaci√≥n:', error.message);
    throw error;
  }
}

/**
 * Funci√≥n para configurar headers de autenticaci√≥n
 */
function setAuthHeaders() {
  if (sessionToken) {
    // Simular el comportamiento del cliente con headers personalizados
    console.log('üîß Configurando headers de autenticaci√≥n...');
  }
}

/**
 * Funci√≥n para probar operaciones CRUD en sermon_categories
 */
async function testSermonCategories() {
  console.log('üìñ Paso 2: Probando sermon_categories...');
  setAuthHeaders();
  
  try {
    // Crear categor√≠a
    const { data: category, error: createError } = await supabase
      .from('sermon_categories')
      .insert({
        name: 'Categor√≠a de Prueba Integraci√≥n',
        description: 'Descripci√≥n de prueba para integraci√≥n',
        slug: 'categoria-prueba-integracion'
      })
      .select()
      .single();

    if (createError) throw createError;
    console.log('‚úÖ Categor√≠a creada:', category.name);

    // Actualizar categor√≠a
    const { data: updatedCategory, error: updateError } = await supabase
      .from('sermon_categories')
      .update({ description: 'Descripci√≥n actualizada' })
      .eq('id', category.id)
      .select()
      .single();

    if (updateError) throw updateError;
    console.log('‚úÖ Categor√≠a actualizada');

    // Eliminar categor√≠a
    const { error: deleteError } = await supabase
      .from('sermon_categories')
      .delete()
      .eq('id', category.id);

    if (deleteError) throw deleteError;
    console.log('‚úÖ Categor√≠a eliminada');
    
    return true;
  } catch (error) {
    console.error('‚ùå Error en sermon_categories:', error.message);
    return false;
  }
}

/**
 * Funci√≥n para probar operaciones CRUD en events
 */
async function testEvents() {
  console.log('üìÖ Paso 3: Probando events...');
  setAuthHeaders();
  
  try {
    // Crear evento
    const { data: event, error: createError } = await supabase
      .from('events')
      .insert({
        title: 'Evento de Prueba Integraci√≥n',
        description: 'Descripci√≥n del evento de prueba',
        event_date: new Date().toISOString(),
        location: 'Ubicaci√≥n de prueba'
      })
      .select()
      .single();

    if (createError) throw createError;
    console.log('‚úÖ Evento creado:', event.title);

    // Actualizar evento
    const { data: updatedEvent, error: updateError } = await supabase
      .from('events')
      .update({ description: 'Descripci√≥n actualizada del evento' })
      .eq('id', event.id)
      .select()
      .single();

    if (updateError) throw updateError;
    console.log('‚úÖ Evento actualizado');

    // Eliminar evento (soft delete)
    const { error: deleteError } = await supabase
      .from('events')
      .update({ is_active: false })
      .eq('id', event.id);

    if (deleteError) throw deleteError;
    console.log('‚úÖ Evento eliminado (soft delete)');
    
    return true;
  } catch (error) {
    console.error('‚ùå Error en events:', error.message);
    return false;
  }
}

/**
 * Funci√≥n para probar operaciones CRUD en blog_categories
 */
async function testBlogCategories() {
  console.log('üìù Paso 4: Probando blog_categories...');
  setAuthHeaders();
  
  try {
    // Crear categor√≠a de blog
    const { data: category, error: createError } = await supabase
      .from('blog_categories')
      .insert({
        name: 'Categor√≠a Blog Integraci√≥n',
        description: 'Descripci√≥n de categor√≠a de blog',
        slug: 'categoria-blog-integracion'
      })
      .select()
      .single();

    if (createError) throw createError;
    console.log('‚úÖ Categor√≠a de blog creada:', category.name);

    // Actualizar categor√≠a
    const { data: updatedCategory, error: updateError } = await supabase
      .from('blog_categories')
      .update({ description: 'Descripci√≥n actualizada de blog' })
      .eq('id', category.id)
      .select()
      .single();

    if (updateError) throw updateError;
    console.log('‚úÖ Categor√≠a de blog actualizada');

    // Eliminar categor√≠a
    const { error: deleteError } = await supabase
      .from('blog_categories')
      .delete()
      .eq('id', category.id);

    if (deleteError) throw deleteError;
    console.log('‚úÖ Categor√≠a de blog eliminada');
    
    return true;
  } catch (error) {
    console.error('‚ùå Error en blog_categories:', error.message);
    return false;
  }
}

/**
 * Funci√≥n para probar operaciones CRUD en blog_posts
 */
async function testBlogPosts() {
  console.log('üì∞ Paso 5: Probando blog_posts...');
  setAuthHeaders();
  
  try {
    // Crear post de blog
    const { data: post, error: createError } = await supabase
      .from('blog_posts')
      .insert({
        title: 'Post de Blog Integraci√≥n',
        content: 'Contenido del post de prueba',
        slug: 'post-blog-integracion',
        status: 'published'
      })
      .select()
      .single();

    if (createError) throw createError;
    console.log('‚úÖ Post de blog creado:', post.title);

    // Actualizar post
    const { data: updatedPost, error: updateError } = await supabase
      .from('blog_posts')
      .update({ content: 'Contenido actualizado del post' })
      .eq('id', post.id)
      .select()
      .single();

    if (updateError) throw updateError;
    console.log('‚úÖ Post de blog actualizado');

    // Eliminar post
    const { error: deleteError } = await supabase
      .from('blog_posts')
      .delete()
      .eq('id', post.id);

    if (deleteError) throw deleteError;
    console.log('‚úÖ Post de blog eliminado');
    
    return true;
  } catch (error) {
    console.error('‚ùå Error en blog_posts:', error.message);
    return false;
  }
}

/**
 * Funci√≥n para probar operaciones CRUD en sermons
 */
async function testSermons() {
  console.log('üé§ Paso 6: Probando sermons...');
  setAuthHeaders();
  
  try {
    // Crear serm√≥n
    const { data: sermon, error: createError } = await supabase
      .from('sermons')
      .insert({
        title: 'Serm√≥n de Prueba Integraci√≥n',
        content: 'Contenido del serm√≥n de prueba',
        sermon_date: new Date().toISOString(),
        speaker: 'Pastor de Prueba'
      })
      .select()
      .single();

    if (createError) throw createError;
    console.log('‚úÖ Serm√≥n creado:', sermon.title);

    // Actualizar serm√≥n
    const { data: updatedSermon, error: updateError } = await supabase
      .from('sermons')
      .update({ content: 'Contenido actualizado del serm√≥n' })
      .eq('id', sermon.id)
      .select()
      .single();

    if (updateError) throw updateError;
    console.log('‚úÖ Serm√≥n actualizado');

    // Eliminar serm√≥n
    const { error: deleteError } = await supabase
      .from('sermons')
      .delete()
      .eq('id', sermon.id);

    if (deleteError) throw deleteError;
    console.log('‚úÖ Serm√≥n eliminado');
    
    return true;
  } catch (error) {
    console.error('‚ùå Error en sermons:', error.message);
    return false;
  }
}

/**
 * Funci√≥n principal de prueba
 */
async function runIntegrationTest() {
  try {
    // Autenticaci√≥n
    await authenticateUser();
    
    // Probar todas las tablas
    const results = {
      sermonCategories: await testSermonCategories(),
      events: await testEvents(),
      blogCategories: await testBlogCategories(),
      blogPosts: await testBlogPosts(),
      sermons: await testSermons()
    };
    
    // Resumen de resultados
    console.log('\nüìä RESUMEN DE RESULTADOS:');
    console.log('========================');
    
    const allPassed = Object.values(results).every(result => result === true);
    
    Object.entries(results).forEach(([table, passed]) => {
      const status = passed ? '‚úÖ PAS√ì' : '‚ùå FALL√ì';
      console.log(`${table}: ${status}`);
    });
    
    console.log('\n' + '='.repeat(50));
    
    if (allPassed) {
      console.log('üéâ ¬°INTEGRACI√ìN COMPLETA EXITOSA!');
      console.log('‚úÖ Todas las operaciones CRUD funcionan correctamente');
      console.log('‚úÖ El sistema de autenticaci√≥n personalizada est√° integrado');
      console.log('‚úÖ El proyecto principal est√° listo para usar');
    } else {
      console.log('‚ö†Ô∏è  INTEGRACI√ìN PARCIAL');
      console.log('‚ùå Algunas operaciones fallaron');
      console.log('üîß Revisa los errores anteriores para m√°s detalles');
    }
    
    console.log('\nüèÅ Prueba de integraci√≥n completada.');
    
  } catch (error) {
    console.error('\nüí• ERROR CR√çTICO EN LA INTEGRACI√ìN:');
    console.error(error.message);
    process.exit(1);
  }
}

// Ejecutar la prueba
runIntegrationTest();